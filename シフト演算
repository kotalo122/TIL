シフト演算とは
2進数をあらわすビット列を左または右にずらす操作のこと。
例)
10進数で考えると「770」という数字を10倍すると「7700」、1/10倍すると「77」となり、10倍は1桁増やす操作であり、1/10倍は1桁減らす操作。
この操作は2進数でも同じ。
「100」（10進数：4）という2進数を2倍すると「1000」（10進数：8）、1/2倍すると「10」（10進数：2）。
ビット列を左にずらすと元の値の2倍、右にずらすと元の値の1/2倍という計算結果を簡単に得ることができる。
コンピュータはこのシフト演算を使い、掛け算や割り算を行う。

論理シフト
符号を考慮せずに行うシフト演算のこと。

論理左シフト
掛け算を行うためには、論理左シフト演算を用いる。論理左シフト演算では、掛ける分だけ左にビット列を移動させる。2倍であれば1ビット、4倍であれば2ビット、8倍であれば3ビットずらすことで、乗算を実現する。
例)
「00111100」（10進数で60）という数値に対して2ビット左にずらすと、「11110000」（10進数で240）となり、数値が4倍される。

論理右シフト
一方で割り算を行うためには、論理右シフト演算を用いる。論理右シフト演算では、割る分だけ右にビット列を移動させる。1/2であれば1ビット、1/4であれば2ビット、1/8であれば3ビットずらすことで、除算を実現することができる。
例)
「00111100」（10進数で60）という数値に対して2ビット右にずらすと、「00001111」（10進数で15）となり、数値が1/4されます。


算術シフト演算
シフト演算のうち符号を考慮するもの。コンピュータ上では先頭ビットが符号を示すため、算術シフト演算では先頭ビット以外をシフトさせる。
また、負数同士の掛け算、割り算であれば、符号を反転させる処理も同時に行います。
掛ける分だけ先頭を除き左にビット列を移動させる。2倍であれば1ビット、4倍であれば2ビット、8倍であれば3ビットずらすことで、乗算を実現する。
例)
数値域を「128～-127」と設定した1バイトの数値である「10011100」（10進数で-28）があるとする。この数値の先頭である「1」は符号を表す数字であり、0であれば＋、1であればマイナスを表す。
この「10011100」に対して、先頭を除き左に2ビットずらすと、「11110000」（10進数で-112）となり、符号を変えずに4倍できていることが分かる。

一方で、算術右シフト演算では割る分だけ先頭を除き右にビット列を移動させます。1/2であれば1ビット、1/4であれば2ビット、1/8であれば3ビットずらすことで、除算を実現します。
例)
「10011100」（10進数で-28）に対して先頭を除き右に2ビットずらすと、「10000111」（10進数で-7）となり、符号を変えずに1/4できていることが分かる。

2の乗数以外の乗算・除算
5や7などの2の乗数以外の乗算・除算を実施する場合
2の乗数以外の乗算・除算を実施する場合、その値を2の乗数に分解したうえで計算を実施する。
例)
「00011100」（10進数で28）に対して6を掛ける場合、6を2の乗数に分解。6は、「2の2乗(=4) ＋ 2の1乗(=2)」と分解できる。
よって、「00011100」に6を掛けたい場合は、「00011100」に対して4を掛けたものと2を掛けたものを足し合わせればよいことが分かる。
「00011100」を左に2ビットずらすと「01110000」（10進数で112）となる。次に、「00011100」を左に1ビットずらすと「00111000」（10進数で56）となる。
これらを足し合わせると、「10101000」（10進数で168）となり、確かに28に6を掛けたものであることが分かる。
